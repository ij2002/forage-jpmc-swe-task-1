From c73fcaf6d125b17b4081020054c86222ac53dba8 Mon Sep 17 00:00:00 2001
From: ij2002 <ij2002@hw.ac.uk>
Date: Thu, 11 Jul 2024 03:41:49 +0530
Subject: [PATCH 1/3] comment

---
 server3.py | 63 ++++++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 57 insertions(+), 6 deletions(-)

diff --git a/server3.py b/server3.py
index 1836de2..0ccd42e 100644
--- a/server3.py
+++ b/server3.py
@@ -21,13 +21,18 @@
 import csv
 # from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
 import http.server
+#data serialization
 import json
 import operator
-import os.path
+#file sys ops
+import os.path #using it to check if file exists
+#regex
 import re
 import threading
+#checking market time prog
 from datetime import timedelta, datetime
 # from itertools import izip
+#random market data
 from random import normalvariate, random
 from socketserver import ThreadingMixIn
 
@@ -40,13 +45,19 @@ import dateutil.parser
 # Sim params
 
 REALTIME = True
+#duration = 5 years
 SIM_LENGTH = timedelta(days=365 * 5)
+#market opens at 12:30 am
 MARKET_OPEN = datetime.today().replace(hour=0, minute=30, second=0)
 
 # Market parms
 #       min  / max  / std
+#spread of prices
+#diference between  best bid and best ask
 SPD = (2.0, 6.0, 0.1)
+#price range
 PX = (60.0, 150.0, 1)
+#freq of price changes
 FREQ = (12, 36, 50)
 
 # Trades
@@ -58,6 +69,7 @@ OVERLAP = 4
 #
 # Test Data
 
+#bounded random walk b/w min and max with std deviation
 def bwalk(min, max, std):
     """ Generates a bounded random walk. """
     rng = max - min
@@ -70,6 +82,7 @@ def market(t0=MARKET_OPEN):
     """ Generates a random series of market conditions,
         (time, price, spread).
     """
+    #uses bwalk to get random vals for hrs, price & spread
     for hours, px, spd in zip(bwalk(*FREQ), bwalk(*PX), bwalk(*SPD)):
         yield t0, px, spd
         t0 += timedelta(hours=abs(hours))
@@ -80,6 +93,7 @@ def orders(hist):
         a series of market conditions.
     """
     for t, px, spd in hist:
+        #market conds
         stock = 'ABC' if random() > 0.5 else 'DEF'
         side, d = ('sell', 2) if random() > 0.5 else ('buy', -2)
         order = round(normalvariate(px + (spd / d), spd / OVERLAP), 2)
@@ -96,6 +110,7 @@ def add_book(book, order, size, _age=10):
     yield order, size, _age
     for o, s, age in book:
         if age > 0:
+            #updated
             yield o, s, age - 1
 
 
@@ -104,28 +119,49 @@ def clear_order(order, size, book, op=operator.ge, _notional=0):
         (notional, new_book) if successful, and None if not.  _notional is a
         recursive accumulator and should not be provided by the caller.
     """
+
+    #gets 1st entry's price, quantity and age and puts the rest of the book in tail
     (top_order, top_size, age), tail = book[0], book[1:]
+    #if order is greater than top order
     if op(order, top_order):
+        #sell order, check if price/size is greater than top buy
+        #if so, add top order to notional
+        #if not, add size to notional 
+        #buy order, check if price less than/eq to top sell order
+        
+        #min of price and top price * top order
         _notional += min(size, top_size) * top_order
+        #difference in size b/w top order and current
         sdiff = top_size - size
+        #remaining of top order added back and notional returned
         if sdiff > 0:
             return _notional, list(add_book(tail, top_order, sdiff, age))
+        #if incoming order not fully cleared, calls clear_order recurively
         elif len(tail) > 0:
             return clear_order(order, -sdiff, tail, op, _notional)
+        #if niether, returns None (aka order couldnt be cleared)
 
 
 def clear_book(buy=None, sell=None):
     """ Clears all crossed orders from a buy and sell book, returning the new
         books uncrossed.
     """
+    #buy & sell not None
     while buy and sell:
+        #1st entry of buy
+        #order - price, size - quantity (both of top buy order), _ ignores age
         order, size, _ = buy[0]
+        #clear the top buy order against the sell  & recieve (notional, updsated sell) or None
         new_book = clear_order(order, size, sell)
-        if new_book:
+        if new_book: #not None
+            #sell order cleared, new book returned
             sell = new_book[1]
+            #buy order cleared, new book returned
             buy = buy[1:]
         else:
+            #when top buy not matched w any sell
             break
+    #updated tuple
     return buy, sell
 
 
@@ -134,10 +170,20 @@ def order_book(orders, book, stock_name):
         are mutable lists, and mutating them during generation will affect the
         next turn!
     """
+    #side = buy/sell
     for t, stock, side, order, size in orders:
         if stock_name == stock:
-            new = add_book(book.get(side, []), order, size)
-            book[side] = sorted(new, reverse=side == 'buy', key=lambda x: x[0])
+            #add matching stock to correct side of book
+            #returns updated list
+            new = add_book(
+                #curent list of orders for the side or empty set if doesnt exoist
+                book.get(side, [])
+                , order, size)
+            #sorts the list in descending order if sell, else ascending
+            book[side] = sorted(new, reverse=side == 'buy', 
+                                #sorting based on price (first element of tuple)
+                                key=lambda x: x[0])
+            #match any crossed orders
         bids, asks = clear_book(**book)
         yield t, bids, asks
 
@@ -245,9 +291,10 @@ def run(routes, host='0.0.0.0', port=8080):
 #
 # App
 
+#maps buy & sell to their respective operators
 ops = {
-    'buy': operator.le,
-    'sell': operator.ge,
+    'buy': operator.le, #less than or equal to
+    'sell': operator.ge, #greater than or equal to
 }
 
 
@@ -255,11 +302,15 @@ class App(object):
     """ The trading game server application. """
 
     def __init__(self):
+        #dicts to store order books 
         self._book_1 = dict()
         self._book_2 = dict()
+        #order data book for stocks ABC and DEF
         self._data_1 = order_book(read_csv(), self._book_1, 'ABC')
         self._data_2 = order_book(read_csv(), self._book_2, 'DEF')
+        #real time start time
         self._rt_start = datetime.now()
+        #simulation start time
         self._sim_start, _, _ = next(self._data_1)
         self.read_10_first_lines()
 
-- 
2.25.1


From fd30d2e7e687754dcb8c899bca1342db5622f5c7 Mon Sep 17 00:00:00 2001
From: ij2002 <ij2002@hw.ac.uk>
Date: Thu, 11 Jul 2024 04:16:57 +0530
Subject: [PATCH 2/3] more comments

---
 client3.py | 26 ++++++++---------
 server3.py | 84 ++++++++++++++++++++++++++++++------------------------
 2 files changed, 59 insertions(+), 51 deletions(-)

diff --git a/client3.py b/client3.py
index 3fc09b7..ff5bdb2 100644
--- a/client3.py
+++ b/client3.py
@@ -20,7 +20,7 @@
 
 import json
 import random
-import urllib.request
+import urllib.request  #to open and read URLs
 
 # Server API URLs
 QUERY = "http://localhost:8080/query?id={}"
@@ -32,28 +32,28 @@ N = 500
 def getDataPoint(quote):
     """ Produce all the needed values to generate a datapoint """
     """ ------------- Update this function ------------- """
-    stock = quote['stock']
-    bid_price = float(quote['top_bid']['price'])
-    ask_price = float(quote['top_ask']['price'])
-    price = bid_price
-    return stock, bid_price, ask_price, price
+    stock = quote['stock'] #get stock name
+    bid_price = float(quote['top_bid']['price']) #get bid price & convert to float
+    ask_price = float(quote['top_ask']['price']) #same for ask
+    price = bid_price 
+    return stock, bid_price, ask_price, price 
 
 
 def getRatio(price_a, price_b):
     """ Get ratio of price_a and price_b """
     """ ------------- Update this function ------------- """
-    return 1
+    return 1 
 
 
 # Main
 if __name__ == "__main__":
     # Query the price once every N seconds.
-    for _ in iter(range(N)):
-        quotes = json.loads(urllib.request.urlopen(QUERY.format(random.random())).read())
+    for _ in iter(range(N)): 
+        quotes = json.loads(urllib.request.urlopen(QUERY.format(random.random())).read()) #get quotes from server
 
         """ ----------- Update to get the ratio --------------- """
-        for quote in quotes:
-            stock, bid_price, ask_price, price = getDataPoint(quote)
-            print("Quoted %s at (bid:%s, ask:%s, price:%s)" % (stock, bid_price, ask_price, price))
+        for quote in quotes: 
+            stock, bid_price, ask_price, price = getDataPoint(quote) #get data point for each quote
+            print("Quoted %s at (bid:%s, ask:%s, price:%s)" % (stock, bid_price, ask_price, price)) 
 
-        print("Ratio %s" % getRatio(price, price))
+        print("Ratio %s" % getRatio(price, price)) 
diff --git a/server3.py b/server3.py
index 0ccd42e..d3e2d7a 100644
--- a/server3.py
+++ b/server3.py
@@ -194,17 +194,24 @@ def order_book(orders, book, stock_name):
 
 def generate_csv():
     """ Generate a CSV of order history. """
+    #open a file in write-binary mode
     with open('test.csv', 'wb') as f:
         writer = csv.writer(f)
+        #orders from market conditions
         for t, stock, side, order, size in orders(market()):
+            #stop when simulation length is reached
             if t > MARKET_OPEN + SIM_LENGTH:
                 break
+                #write details to csv file
             writer.writerow([t, stock, side, order, size])
 
 
 def read_csv():
     """ Read a CSV or order history into a list. """
+    #read the csv file in text mode
     with open('test.csv', 'rt') as f:
+    #read each row in the csv and
+    #parse order details
         for time, stock, side, order, size in csv.reader(f):
             yield dateutil.parser.parse(time), stock, side, float(order), int(size)
 
@@ -217,12 +224,12 @@ class ThreadedHTTPServer(ThreadingMixIn, http.server.HTTPServer):
     """ Boilerplate class for a multithreaded HTTP Server, with working
         shutdown.
     """
-    allow_reuse_address = True
+    allow_reuse_address = True #allow reuse of the address
 
     def shutdown(self):
         """ Override MRO to shutdown properly. """
-        self.socket.close()
-        http.server.HTTPServer.shutdown(self)
+        self.socket.close() #close the server socket
+        http.server.HTTPServer.shutdown(self) #shutdown the HTTP server
 
 
 def route(path):
@@ -231,6 +238,7 @@ def route(path):
     """
 
     def _route(f):
+        #set route of the function to the given path
         setattr(f, '__route__', path)
         return f
 
@@ -241,24 +249,24 @@ def read_params(path):
     """ Read query parameters into a dictionary if they are parseable,
         otherwise returns None.
     """
-    query = path.split('?')
-    if len(query) > 1:
-        query = query[1].split('&')
-        return dict(map(lambda x: x.split('='), query))
+    query = path.split('?') #split path at '?' to separate base path and query
+    if len(query) > 1: #check if there are query parameters
+        query = query[1].split('&') #split query parameters at '&' to get individual key-value pairs
+        return dict(map(lambda x: x.split('='), query)) #split each key-value pair at '=' and convert to dictionary
 
 
 def get(req_handler, routes):
     """ Map a request to the appropriate route of a routes instance. """
     for name, handler in routes.__class__.__dict__.items():
-        if hasattr(handler, "__route__"):
-            if None != re.search(handler.__route__, req_handler.path):
-                req_handler.send_response(200)
-                req_handler.send_header('Content-Type', 'application/json')
-                req_handler.send_header('Access-Control-Allow-Origin', '*')
-                req_handler.end_headers()
-                params = read_params(req_handler.path)
-                data = json.dumps(handler(routes, params)) + '\n'
-                req_handler.wfile.write(bytes(data, encoding='utf-8'))
+        if hasattr(handler, "__route__"): #check if handler has a route
+            if None != re.search(handler.__route__, req_handler.path): #match the route with the request path
+                req_handler.send_response(200) #send HTTP 200 OK response
+                req_handler.send_header('Content-Type', 'application/json') #set response content type to JSON
+                req_handler.send_header('Access-Control-Allow-Origin', '*') #allow cross-origin requests
+                req_handler.end_headers() #end headers section
+                params = read_params(req_handler.path) #parse query parameters
+                data = json.dumps(handler(routes, params)) + '\n' #call handler and convert result to JSON
+                req_handler.wfile.write(bytes(data, encoding='utf-8')) #write response data to output stream
                 return
 
 
@@ -275,9 +283,9 @@ def run(routes, host='0.0.0.0', port=8080):
             get(self, routes)
 
     server = ThreadedHTTPServer((host, port), RequestHandler)
-    thread = threading.Thread(target=server.serve_forever)
-    thread.daemon = True
-    thread.start()
+    thread = threading.Thread(target=server.serve_forever) #create a new thread to run the server
+    thread.daemon = True #set the thread as a daemon thread (background thread that doesnt prevent program from exiting when all non-daemon threads have completed)
+    thread.start() 
     print('HTTP server started on port 8080')
     while True:
         from time import sleep
@@ -319,7 +327,7 @@ class App(object):
         for t, bids, asks in self._data_1:
             if REALTIME:
                 while t > self._sim_start + (datetime.now() - self._rt_start):
-                    yield t, bids, asks
+                    yield t, bids, asks #yield data if real time
             else:
                 yield t, bids, asks
 
@@ -334,8 +342,8 @@ class App(object):
 
     def read_10_first_lines(self):
         for _ in iter(range(10)):
-            next(self._data_1)
-            next(self._data_2)
+            next(self._data_1) #read next line of data_1
+            next(self._data_2) 
 
     @route('/query')
     def handle_query(self, x):
@@ -347,22 +355,22 @@ class App(object):
             t2, bids2, asks2 = next(self._current_book_2)
         except Exception as e:
             print("error getting stocks...reinitalizing app")
-            self.__init__()
-            t1, bids1, asks1 = next(self._current_book_1)
-            t2, bids2, asks2 = next(self._current_book_2)
-        t = t1 if t1 > t2 else t2
+            self.__init__() #reinitialize app if error
+            t1, bids1, asks1 = next(self._current_book_1) 
+            t2, bids2, asks2 = next(self._current_book_2) 
+        t = t1 if t1 > t2 else t2 #get latest timestamp
         print('Query received @ t%s' % t)
         return [{
-            'id': x and x.get('id', None),
+            'id': x and x.get('id', None), #get id if exists
             'stock': 'ABC',
             'timestamp': str(t),
             'top_bid': bids1 and {
-                'price': bids1[0][0],
-                'size': bids1[0][1]
+                'price': bids1[0][0], #get top bid price
+                'size': bids1[0][1] #get top bid size
             },
             'top_ask': asks1 and {
-                'price': asks1[0][0],
-                'size': asks1[0][1]
+                'price': asks1[0][0], #get top ask price
+                'size': asks1[0][1] #get top ask size
             }
         },
             {
@@ -370,12 +378,12 @@ class App(object):
                 'stock': 'DEF',
                 'timestamp': str(t),
                 'top_bid': bids2 and {
-                    'price': bids2[0][0],
-                    'size': bids2[0][1]
+                    'price': bids2[0][0], #get top bid price
+                    'size': bids2[0][1] #get top bid size
                 },
                 'top_ask': asks2 and {
-                    'price': asks2[0][0],
-                    'size': asks2[0][1]
+                    'price': asks2[0][0], #get top ask price
+                    'size': asks2[0][1] #get top ask size
                 }
             }]
 
@@ -385,7 +393,7 @@ class App(object):
 # Main
 
 if __name__ == '__main__':
-    if not os.path.isfile('test.csv'):
-        print("No data found, generating...")
-        generate_csv()
+    if not os.path.isfile('test.csv'): #check if test.csv exists
+        print("No data found, generating...") #notify user no data found
+        generate_csv() #create test.csv if not found
     run(App())
-- 
2.25.1


From 06d4e5979bbe71a9a9a29260f0ba236a5a142fb2 Mon Sep 17 00:00:00 2001
From: ij2002 <ij2002@hw.ac.uk>
Date: Thu, 11 Jul 2024 05:47:29 +0530
Subject: [PATCH 3/3] task1 completed

---
 client3.py | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/client3.py b/client3.py
index ff5bdb2..514c711 100644
--- a/client3.py
+++ b/client3.py
@@ -35,25 +35,33 @@ def getDataPoint(quote):
     stock = quote['stock'] #get stock name
     bid_price = float(quote['top_bid']['price']) #get bid price & convert to float
     ask_price = float(quote['top_ask']['price']) #same for ask
-    price = bid_price 
+    price = (bid_price+ask_price) / 2
     return stock, bid_price, ask_price, price 
 
 
 def getRatio(price_a, price_b):
     """ Get ratio of price_a and price_b """
-    """ ------------- Update this function ------------- """
-    return 1 
+    if price_b == 0:
+        return None #avoid division by 0
+    return price_a / price_b
 
 
 # Main
 if __name__ == "__main__":
-    # Query the price once every N seconds.
+    # Query the price once every n seconds.
     for _ in iter(range(N)): 
         quotes = json.loads(urllib.request.urlopen(QUERY.format(random.random())).read()) #get quotes from server
 
+        prices = {}  #dictionary to store stock prices
+
         """ ----------- Update to get the ratio --------------- """
         for quote in quotes: 
             stock, bid_price, ask_price, price = getDataPoint(quote) #get data point for each quote
+            prices[stock] = price  #store the price in the dictionary
             print("Quoted %s at (bid:%s, ask:%s, price:%s)" % (stock, bid_price, ask_price, price)) 
 
-        print("Ratio %s" % getRatio(price, price)) 
+        # print("Ratio %s" % getRatio(price, price)) 
+        
+        #ensure both stocks are in the prices dictionary before calculating the ratio
+        if 'ABC' in prices and 'DEF' in prices:
+            print("Ratio %s" % getRatio(prices['ABC'], prices['DEF'])) 
-- 
2.25.1

